---
title: "calculate_weights"
output: html_document
date: '2023-03-03'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r }

library(ggplot2)
library(spatialLIBD)
library(nnSVG)

spe <- fetch_data(type = "spe")
spe_151507 <- spe[, spe$sample_id == "151507"]
spe_151507 <- spe_151507[, !is.na(unfactor(colData(spe_151507)$spatialLIBD))]

spe_151507 <- filter_genes(spe_151507)

# Count Matrix, each row is a sample, and each column is a gene
r <- as.matrix(counts(spe_151507))

n <- dim(spe_151507)[1] # Number of Cells
G <- dim(spe_151507)[2] # Number of Genes

# Sample-specific Library Size
R <- rowSums(r)
stopifnot(length(R)==n)

# Temporary Matrix, replicate library size for each row
tmp_R_mat <- matrix(
  rep(R, each = G),
  byrow = TRUE, nrow = n, ncol = G
)

# logCPM
y <- log2(r+0.5) - log2(tmp_R_mat+1) + log2(10^6)


# Viz Mean-variance -------------------------------------------------------
data.frame(
  y = apply(y, MARGIN = 2, sd) |>
    sqrt(),   # Square root of the standard deviation of logCPM (y_i)  
  x = log(r+0.5, base = 2) |> 
    colMeans() # log2(r_i + 0.5)
) |> 
  ggplot() +
  geom_point(aes(x = x, y = y)) +
  labs(
    x = "log2(count size + 0.5)",
    y = "Sqrt(standard deviation)"
  )


# Calc Weight -------------------------------------------------------------

X <- matrix(data = 1, nrow = n, ncol = 1)  # Intercept for each gene

# *Linear Models ----------------------------------------------------------
lm_fit <- lm(y~X-1) # Multivariate Linear Regression

beta_hat <- coef(lm_fit)
stopifnot(dim(beta_hat)==c(ncol(X),G))


# *Voom Variance Modelling -------------------------------------------------

mu_hat <- predict(lm_fit)
# Equivalently
# mu_hat2 <- X %*% beta_hat
stopifnot(dim(mu_hat) == c(n, G))

s_g <- lm_fit$residuals |> 
  apply(MARGIN = 2,  # Column wise
        FUN = sd)
stopifnot(length(s_g) == G)

y_bar <- colMeans(mu_hat)
stopifnot(length(y_bar) == G)

# Geometric Mean
R_tilda <- exp(mean(log(R)))
# The reason of calculating log is to avoid integer overflow

# Log2 Counts
# Note: slight notation abuse. Prev r denotes read counts
r_tilda <- y_bar + log2(R_tilda) - log2(10^6)
stopifnot(length(r_tilda)==G)

# *Plot Relationship -----------------------------------------------------


data.frame(
  y = sqrt(s_g),
  x = r_tilda
) |> 
  ggplot() +
  geom_point(aes(x = x, y = y)) +
  geom_smooth(aes(x = x, y = y)) +
  labs(
    x = "log2(count size)",
    y = "Sqrt(s_g)"
  )


# *LOWESS -----------------------------------------------------------------
loess_fit <- loess(sqrt(s_g)~r_tilda)

stopifnot(dim(mu_hat)==dim(tmp_R_mat))
lambda_hat <- mu_hat + log2(tmp_R_mat+1) - log2(10^6)

# NOTE: It is possible that lambda is out of range of r_tilda
# which will produce NA predicted values due to extrapolation
tmp_pred_sqrt_sg <- predict(
  loess_fit, 
  newdata = data.frame(
    r_tilda = c(lambda_hat)
  )
) |> 
  matrix(
    nrow = n, ncol = G
  )

w <- tmp_pred_sqrt_sg^(-4) 

#remove genes/samples with NA, for now
#sum(is.na(w))/(dim(w)[1]*dim(w)[2])  0.828 NA in w when using umi, 0.389 NA in w when using filter genes
#w1 <- w[complete.cases(w), ] removes all genes
#w2 <- w[, which(colMeans(!is.na(w)) > 0)] removes all samples

#multiply logcounts matrix by weight

```





